#!/usr/bin/env python3
"""
Heuristic static analyzer for the ossfuzz-target project.

Reads the code database JSON (generated by start.py / code-db-builder) and scans
functions for common vulnerability patterns, emitting findings as JSON.

Usage:
  python3 code-ql/analyze.py [code-db-json] [output-json]

Defaults:
  code-db-json: ./code-db-builder/code_db.json
  output-json:  ./code-ql/findings.json
"""

import json
import re
import sys
from pathlib import Path
from typing import Dict, List

ROOT = Path(__file__).resolve().parent.parent
DEFAULT_DB = ROOT / "code-db-builder" / "code_db.json"
DEFAULT_OUT = ROOT / "code-ql" / "findings.json"


def load_code_db(db_path: Path) -> Dict:
    if not db_path.exists():
        raise SystemExit(f"[analyze] Code DB not found: {db_path}. Run start.py first.")
    return json.loads(db_path.read_text())


def detect_issues(lines: List[str]) -> List[Dict[str, str]]:
    issues: List[Dict[str, str]] = []
    joined = "\n".join(lines)

    # Unsafe copy operations.
    if re.search(r"\b(memcpy|strcpy|strcat|sprintf)\s*\(", joined):
        issues.append({"type": "unsafe_copy", "detail": "Uses memcpy/strcpy/strcat/sprintf without bounds checks"})

    # Format string risk: printf-like without string literal.
    for line in lines:
        if "printf(" in line:
            if not re.search(r"printf\s*\(\s*\"", line):
                issues.append({"type": "format_string", "detail": f"printf without literal format: {line.strip()}"})
                break

    # Suspicious allocation math.
    if re.search(r"malloc\s*\([^)]*-\s*[^)]+\)", joined):
        issues.append({"type": "allocation_math", "detail": "malloc size uses subtraction; potential under-allocation"})

    # Double free / UAF hints.
    frees = re.findall(r"free\s*\(\s*([A-Za-z_][A-Za-z0-9_]*)\s*\)", joined)
    if len(frees) > 1:
        issues.append({"type": "double_free", "detail": f"Multiple frees detected: {', '.join(frees)}"})
    if frees:
        first_free = frees[0]
        # Check for use after free by looking for identifier use after the first free.
        seen_free = False
        for line in lines:
            if re.search(rf"free\s*\(\s*{re.escape(first_free)}\s*\)", line):
                seen_free = True
                continue
            if seen_free and re.search(rf"\b{re.escape(first_free)}\b", line):
                issues.append({"type": "use_after_free", "detail": f"Use of '{first_free}' after free"})
                break

    return issues


def analyze(db: Dict, root: Path) -> List[Dict[str, object]]:
    findings: List[Dict[str, object]] = []
    for file_entry in db.get("files", []):
        rel_path = file_entry.get("path")
        if not rel_path:
            continue
        abs_path = root / rel_path
        if not abs_path.exists():
            continue
        file_lines = abs_path.read_text().splitlines()
        for func in file_entry.get("functions", []):
            start = func.get("start_line")
            end = func.get("end_line")
            name = func.get("name")
            if not (name and isinstance(start, int) and isinstance(end, int) and start >= 1 and end >= start):
                continue
            snippet = file_lines[start - 1 : end]
            issues = detect_issues(snippet)
            if issues:
                findings.append(
                    {
                        "file": str(rel_path),
                        "function": name,
                        "start_line": start,
                        "end_line": end,
                        "issues": issues,
                    }
                )
    return findings


def main() -> None:
    args = sys.argv[1:]
    db_path = Path(args[0]) if len(args) >= 1 else DEFAULT_DB
    out_path = Path(args[1]) if len(args) >= 2 else DEFAULT_OUT

    db = load_code_db(db_path)
    root = Path(db.get("project_root", ROOT))
    findings = analyze(db, root)

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(json.dumps(findings, indent=2) + "\n")
    print(f"[analyze] Wrote findings to {out_path}")
    json.dump(findings, sys.stdout, indent=2)
    sys.stdout.write("\n")


if __name__ == "__main__":
    main()
